"use strict";class SudokuBoard{boxSizeX;boxSizeY;dimensionX;dimensionY;cellNumber;maxNumber;cells;rows;cols;boxes;constructor(boxSizeX,boxSizeY,puzzle=null){return this.boxSizeX=boxSizeX,this.boxSizeY=boxSizeY,this.dimensionX=boxSizeX**2,this.dimensionY=boxSizeY**2,this.cellNumber=this.dimensionX*this.dimensionY,this.maxNumber=this.boxSizeX*this.boxSizeY,this.cells=[],this.rows=[],this.cols=[],this.boxes=[],this.generateBoard(),puzzle&&this.setBoard(puzzle),this}generateBoard(){this.createCells(),this.createRows(),this.createCols(),this.createBoxes()}createCells(){if(!(this.cells.length<=this.cellNumber))throw new Error(`Something went wrong, only number of ${this.cellNumber} cells allowed you tried to create the +1.`);for(let y=0;y<this.dimensionY;y++)for(let x=0;x<this.dimensionX;x++){const bx=Math.floor(x/this.boxSizeX),by=Math.floor(y/this.boxSizeY),cell=new Cell({id:y*this.dimensionX+x,x:x,y:y,boxId:this.boxSizeX*by+bx,bx:bx,by:by,accepted:{unfilled:0,min:1,max:this.maxNumber},given:!1,issued:!1});this.cells.push(cell)}}get cells(){return this.cells}boardProperties(){return this.cells.map(cell=>cell.getInfo())}clearIssued(){this.cells.forEach(cell=>cell.setUnIssued())}filterSameBatchID(dimension,id){const collector=[];for(let i=0;i<dimension;i++){const batch=new Batch(i,dimension);this.cells.filter(cell=>cell[id]==i).forEach(cell=>batch.addCell(cell)),collector.push(batch)}if(collector.length!==dimension)throw new Error(`There is more columns (${collector.length}) then allowed (${dimension}).`);return collector}createCols(){this.cols=this.filterSameBatchID(this.dimensionX,"x")}createRows(){this.rows=this.filterSameBatchID(this.dimensionY,"y")}createBoxes(){this.boxes=this.filterSameBatchID(this.cellNumber,"boxId")}getRow(rowNr){return this.rows[rowNr]}getAllRows(){return this.rows}getCol(colNr){return this.cols[colNr]}getBox(boxNr){return this.boxes[boxNr]}filterValuesFromBatch(batch){return batch.getCells().map(cell=>cell.value)}getRowValues(rowNr){return this.filterValuesFromBatch(this.getRow(rowNr))}getColValues(colNr){return this.filterValuesFromBatch(this.getCol(colNr))}getBoxValues(boxNr){return this.filterValuesFromBatch(this.getBox(boxNr))}getMissingFromRow(rowNr){return this.getRow(rowNr).getMissingNumbers()}getFilledFromRow(rowNr){return this.getRow(rowNr).getFilledNumbers()}getMissingFromCol(colNr){return this.getCol(colNr).getMissingNumbers()}getFilledFromCol(colNr){return this.getCol(colNr).getFilledNumbers()}getMissingFromBox(boxNr){return this.getBox(boxNr).getMissingNumbers()}getFilledFromBox(boxNr){return this.getBox(boxNr).getFilledNumbers()}getCellPossiblities({x:x,y:y,cell:cell}){cell||(cell=this.getCellByCoords(x,y));const missingFromCol=this.getMissingFromCol(cell.x),missingFromRow=this.getMissingFromRow(cell.y),missingFromBox=this.getMissingFromBox(cell.boxId),intersection=(arr1,arr2)=>arr1.filter(value=>arr2.includes(value));return intersection(intersection(missingFromCol,missingFromRow),missingFromBox)}hasColumnDuplicates(colNr){return this.getCol(colNr).hasDuplicates()}hasRowDuplicates(rowNr){return this.getRow(rowNr).hasDuplicates()}hasBoxDuplicates(boxNr){return this.getBox(boxNr).hasDuplicates()}hasCellDuplicates({x:x,y:y,cell:cell}){return cell||(cell=this.getCellByCoords(x,y)),this.hasColumnDuplicates(cell.y)&&this.hasRowDuplicates(cell.x)&&this.hasBoxDuplicates(cell.boxId)}getIssuedCells(){return[...new Set([...this.rows,...this.cols,...this.boxes].map(batch=>batch.getDuplicateValuedCells()).flat())]}puzzleIsCorrect(){return[...this.rows,...this.cols,...this.boxes].forEach(batch=>{if(batch.hasDuplicates())return!1}),!0}getFirstFeeCell(){const freeCell=this.cells.find(cell=>0==cell.value);return freeCell||!1}coordsOfFirstFreeCell(){const freeCell=this.getFirstFeeCell();return!!freeCell&&{x:freeCell.x,y:freeCell.y}}validateCoord(x,y){return 0<=x&&x<=this.dimensionX-1&&0<=y&&y<=this.dimensionY-1}getCellByCoords(x,y){if(this.validateCoord(x,y))return this.cells.find(cell=>cell.x==x&&cell.y==y);throw new Error(`The x coordinate value must be between 1...${this.dimensionX}, the y must be between 1...${this.dimensionY}. You asked x: ${x} and y: ${y}.`)}boardFormat(board){return Array.isArray(board)?board.length===this.dimensionY?board.every(row=>row.length===this.dimensionX&&Array.isArray(row))?["2D"]:["err",`Input array of the setBoard method in case 2D array ${this.dimensionY} times ${this.dimensionX} sized.`]:board.length===this.cellNumber?["1D"]:["err",`Input array of the setBoard method in case of 1D array must be exactly ${this.cellNumber} element.`]:"string"==typeof board?board.length===this.cellNumber?["string"]:["err",`Input of the setBoard method must be exactly ${this.cellNumber} character long string this string is ${board.length}.`]:["err","The board format is invalid!"]}setBoard(board,setGiven=!1){const[format,msg]=this.boardFormat(board),convertFormat={"2D":()=>board,"1D":()=>{const board2D=[];for(;board.length;)board2D.push(board.splice(0,this.dimensionX));return board2D},string:()=>this.setBoard(board.split(""),setGiven),err:()=>{throw new Error(msg)}};convertFormat[format]().forEach((row,y)=>row.forEach((cellValue,x)=>{const cell=this.getCellByCoords(x,y);cell.setValue(cellValue),setGiven&&(cell.isFilled()?cell.setGiven():cell.unsetGiven())})),this.setAllIssuedCells()}get cells(){return this.cells}getCellValues({format:format,unfilledChar:unfilledChar}={format:"1D",unfilledChar:"0"}){let res=this.cells.map(cell=>cell.value);if("STRING"===format.toUpperCase())return res.join("").replace(/0/g,unfilledChar);if("2D"===format.toUpperCase()){const board2D=[];for(;res.length;)board2D.push(res.splice(0,this.dimensionX));return board2D}return res}getCellValue(x,y){return this.getCellByCoords(x,y).value}setCellValue({x:x,y:y,cell:cell,id:id},value){let selectedCell;if(cell)selectedCell=cell;else if(void 0!==x&&void 0!==y)selectedCell=this.getCellByCoords(x,y);else{if(void 0===id)throw new Error(`The setCellValue arguments must be x (${x}), y (${y}), or a Cell (${cell}) object, or an id (${id})! There is no such cell that meets the requirements.`);selectedCell=this.cells.find(cell=>cell.id===id)}selectedCell&&(selectedCell.setValue(value),this.setAllIssuedCells())}setAllIssuedCells(){this.clearIssued(),this.getIssuedCells().forEach(issuedCell=>issuedCell.setIssued())}}class Batch{id;cells=[];validValues=[];unfilledValue;minValue;maxValue;cellNumber;constructor(id,cellNumber){this.id=id,this.cellNumber=cellNumber}set id(id){this.id=id}get id(){return this.id}addCell(cell){const accepted=cell.getAccepted();if(0==this.cells.length&&(this.unfilledValue=accepted.unfilled,this.minValue=accepted.min,this.maxValue=accepted.max,this.validValues=Array.from({length:accepted.max},(_,i)=>i+accepted.min)),this.unfilledValue!==accepted.unfilled||this.minValue!==accepted.min||this.maxValue!==accepted.max)throw new Error("The current cell that would be added has not the same value acceptance as the cells that are already in the batch.");if(this.cells.push(cell),this.cells.length>this.cellNumber)throw new Error(`There is more cells in this batch (${this.cells.length}) then allowed (${this.cellNumber}).`)}getCellValues(){return this.cells.map(cell=>cell.value)}getMissingNumbers(){return this.validValues.filter(value=>!this.getCellValues().includes(value))}getFilledNumbers(){return this.validValues.filter(value=>this.getCellValues().includes(value))}hasDuplicates(){return this.getDuplicateValues().length>0}getDuplicateValuedCells(){return this.cells.filter(cell=>this.getDuplicateValues().includes(cell.value))}getDuplicateValues(){return Array.from({length:this.maxValue-this.minValue+1},(_,i)=>i+1).filter(validNum=>this.cells.filter(cell=>cell.value===validNum).length>1)}getCellByValue(value){return this.cells.filter(cell=>cell.value===value)}getCellByIndex(i){return this.cells[i]}getCells(){return this.cells}findAndSetIssued(){this.getDuplicateValuedCells().forEach(cell=>cell.setIssued())}clearIssued(){this.cells.forEach(cell=>cell.setUnIssued())}}class Cell{given;issued;value;x;y;bx;by;id;boxId;accepted;ref;constructor({x:x,y:y,bx:bx,by:by,id:id,boxId:boxId,value:value,accepted:accepted,given:given,issued:issued,ref:ref}){this.x=x,this.y=y,this.bx=bx,this.id=id,this.boxId=boxId,this.by=by,this.accepted=accepted,this.value=accepted.unfilled,this.given=given||!1,this.issued=issued||!1,this.ref=ref||null}get x(){return this.x}get y(){return this.y}get bx(){return this.bx}get by(){return this.by}get id(){return this.id}get boxId(){return this.boxId}get value(){return this.value}getInfo(){return{id:this.id,given:this.given,issued:this.issued,value:this.value,x:this.x,y:this.y,bx:this.bx,by:this.by,id:this.id,boxId:this.boxId,accepted:this.accepted}}validateValue(value){return value>=this.accepted.min&&value<=this.accepted.max||value===this.accepted.unfilled}setValue(newValue){if("number"!=typeof newValue)throw new Error("Set value must be a number!");if(!this.validateValue(newValue))throw this.value=this.accepted.unfilled,new Error(`Valid cell value is between: ${this.accepted.min} - ${this.accepted.max}, value: ${this.accepted.unfilled} is allowed for unfilled cells.\nYou tried to set value: ${newValue}, for cell(x=${this.x}, y=${this.y}) but value set to: ${this.accepted.unfilled}, because of this issue.`);this.value=newValue}get given(){return this.given}setGiven(){this.given=!0}unsetGiven(){this.given=!1}get issued(){return this.issued}setIssued(){this.issued=!0}setUnIssued(){this.issued=!1}getAccepted(){return this.accepted}isFilled(){return this.value!==this.getAccepted().unfilled}isUnfilled(){return this.value===this.getAccepted().unfilled}getRef(){return this.ref}setRef(ref){this.ref=ref}}
//# sourceMappingURL=SudokuBoard.min.js.map